#!/usr/bin/env run-cargo-script
//! ```cargo
//! [dependencies]
//! serde = { version = "1.0", features = ["derive"] }
//! serde_json = "1.0"
//! simple-error = "0.2.1"
//! ```

extern crate serde;
extern crate serde_json;
extern crate simple_error;

use serde::{Deserialize, Serialize};
use simple_error::SimpleError;
use std::process::{Command, ExitStatus, Output, Stdio};
use std::str;

fn main() -> Result<(), SimpleError> {
    let configuration_name = "secret-store";
    let secret_project = "purplebooth-secret-storage";
    let keyring = "sops";
    let key = "sops-key";

    let active_configuration = active_configuration().expect("Failed to get active configuration");
    let configurations = configurations().expect("Failed to load configuration config");

    if !configurations.contains(&configuration_name.to_string()) {
        create_configuration(&configuration_name).expect(&format!(
            "Failed to create configuration \"{}\"",
            configuration_name
        ));
    }

    match active_configuration {
        Some(active_configuration) => {
            activate_configuration(&active_configuration).expect(&format!(
                "Failed to activate configuration \"{}\"",
                configuration_name
            ));
            ()
        }
        _ => (),
    }

    set_project(secret_project, configuration_name).expect(&format!(
        "Failed to set project \"{}\" in configuration \"{}\"",
        secret_project, configuration_name
    ));

    if !is_logged_in(configuration_name)
        .expect(&format!(
            "Login command failed with configuration \"{}\"",
            configuration_name
        ))
        .success()
    {
        login(configuration_name).expect(&format!(
            "Failed to login to configuration \"{}\"",
            configuration_name
        ));
    }

    if !is_cloudkms_service_enabled(configuration_name).expect(&format!(
        "Failed check if cloudkms is enabled with config \"{}\"",
        configuration_name
    )) {
        enable_cloudkms_service(configuration_name).expect(&format!(
            "Failed to enable cloudkms service with config \"{}\"",
            configuration_name
        ));
    }

    if !is_keyring_existent(configuration_name, secret_project, keyring).expect(&format!(
        "Failed check if keyring \"{}\" in project \"{}\" exists with config \"{}\"",
        keyring, secret_project, configuration_name
    )) {
        create_keyring(configuration_name, keyring).expect(&format!(
            "Failed create keyring \"{}\" in project \"{}\" exists with config \"{}\"",
            keyring, secret_project, configuration_name
        ));
    }

    if !is_key_existent(configuration_name, secret_project, keyring, key).expect(&format!(
        "Failed check if key \"{}\" in keyring \"{}\" in project \"{}\" exists with config \"{}\"",
        key, keyring, secret_project, configuration_name
    )) {
        create_key(configuration_name, keyring, key).expect(&format!(
            "Failed create key \"{}\" keyring \"{}\" in project \"{}\" exists with config \"{}\"",
            key, keyring, secret_project, configuration_name
        ));
    }

    Ok(())
}

#[derive(Serialize, Deserialize, Debug)]
struct Configuration<'a> {
    name: &'a str,
}

fn active_configuration() -> Result<Option<String>, SimpleError> {
    let output = Command::new("gcloud")
        .arg("config")
        .arg("configurations")
        .arg("list")
        .arg("--filter")
        .arg("is_active:true")
        .arg("--format")
        .arg("json")
        .output()
        .or_else(|e| Err(SimpleError::from(e)))?;
    let output_stdout = str::from_utf8(&output.stdout).or_else(|e| Err(SimpleError::from(e)))?;
    let value: Vec<Configuration> = serde_json::from_str::<Vec<Configuration>>(&output_stdout)
        .or_else(|e| Err(SimpleError::from(e)))?;
    let configurations: Vec<String> = value
        .into_iter()
        .map(|x: Configuration| x.name.to_string())
        .collect();

    return match configurations.last() {
        None => Ok(None),
        Some(output) => Ok(Some(output.to_string())),
    };
}

fn configurations() -> Result<Vec<String>, SimpleError> {
    let output = Command::new("gcloud")
        .arg("config")
        .arg("configurations")
        .arg("list")
        .arg("--format")
        .arg("json")
        .output()
        .or_else(|e| Err(SimpleError::from(e)))?;
    let output_stdout = str::from_utf8(&output.stdout).or_else(|e| Err(SimpleError::from(e)))?;
    let value: Vec<Configuration> = serde_json::from_str::<Vec<Configuration>>(&output_stdout)
        .or_else(|e| Err(SimpleError::from(e)))?;
    return Ok(value
        .into_iter()
        .map(|x: Configuration| x.name.to_string())
        .collect::<Vec<String>>());
}

fn create_configuration(configuration: &str) -> Result<Output, SimpleError> {
    Command::new("gcloud")
        .arg("config")
        .arg("configurations")
        .arg("create")
        .arg(configuration)
        .output()
        .or_else(|e| Err(SimpleError::from(e)))
}

fn activate_configuration(configuration: &str) -> Result<Output, SimpleError> {
    Command::new("gcloud")
        .arg("config")
        .arg("configurations")
        .arg("activate")
        .arg(configuration)
        .output()
        .or_else(|e| Err(SimpleError::from(e)))
}

fn set_project(project: &str, configuration: &str) -> Result<Output, SimpleError> {
    Command::new("gcloud")
        .arg("config")
        .arg("set")
        .arg("project")
        .arg(project)
        .arg("--configuration")
        .arg(configuration)
        .output()
        .or_else(|e| Err(SimpleError::from(e)))
}

fn is_logged_in(configuration: &str) -> Result<ExitStatus, SimpleError> {
    Command::new("gcloud")
        .stdout(Stdio::null())
        .arg("auth")
        .arg("print-identity-token")
        .arg("--configuration")
        .arg(configuration)
        .status()
        .or_else(|e| Err(SimpleError::from(e)))
}

fn login(configuration: &str) -> Result<Output, SimpleError> {
    Command::new("gcloud")
        .arg("auth")
        .arg("login")
        .arg("--configuration")
        .arg(configuration)
        .output()
        .or_else(|e| Err(SimpleError::from(e)))
}

fn is_cloudkms_service_enabled(configuration: &str) -> Result<bool, SimpleError> {
    let output = Command::new("gcloud")
        .arg("services")
        .arg("list")
        .arg("--format")
        .arg("json")
        .arg("--enabled")
        .arg("--filter")
        .arg("name:cloudkms.googleapis.com")
        .arg("--configuration")
        .arg(configuration)
        .output()
        .or_else(|e| Err(SimpleError::from(e)))?;
    let output_stdout = str::from_utf8(&output.stdout).or_else(|e| Err(SimpleError::from(e)))?;
    let value: Vec<Configuration> =
        serde_json::from_str::<Vec<_>>(&output_stdout).or_else(|e| Err(SimpleError::from(e)))?;
    return Ok(value.len() > 0);
}

fn enable_cloudkms_service(configuration: &str) -> Result<bool, SimpleError> {
    let output = Command::new("gcloud")
        .arg("services")
        .arg("enable")
        .arg("cloudkms.googleapis.com")
        .arg("--configuration")
        .arg(configuration)
        .output()
        .or_else(|e| Err(SimpleError::from(e)))?;
    let output_stdout = str::from_utf8(&output.stdout).or_else(|e| Err(SimpleError::from(e)))?;
    let value: Vec<Configuration> =
        serde_json::from_str::<Vec<_>>(&output_stdout).or_else(|e| Err(SimpleError::from(e)))?;
    return Ok(value.len() > 0);
}

fn is_keyring_existent(
    configuration: &str,
    project: &str,
    keyring: &str,
) -> Result<bool, SimpleError> {
    let output = Command::new("gcloud")
        .arg("kms")
        .arg("keyrings")
        .arg("list")
        .arg("--location")
        .arg("global")
        .arg("--filter")
        .arg(format!(
            "name:projects/{}/locations/global/keyRings/{}",
            project, keyring
        ))
        .arg("--format")
        .arg("json")
        .arg("--configuration")
        .arg(configuration)
        .output()
        .or_else(|e| Err(SimpleError::from(e)))?;
    let output_stdout = str::from_utf8(&output.stdout).or_else(|e| Err(SimpleError::from(e)))?;
    let value: Vec<Configuration> =
        serde_json::from_str::<Vec<_>>(&output_stdout).or_else(|e| Err(SimpleError::from(e)))?;
    return Ok(value.len() > 0);
}

fn create_keyring(configuration: &str, keyring: &str) -> Result<Output, SimpleError> {
    Command::new("gcloud")
        .arg("kms")
        .arg("keyrings")
        .arg("create")
        .arg(keyring)
        .arg("--location")
        .arg("global")
        .arg("--configuration")
        .arg(configuration)
        .output()
        .or_else(|e| Err(SimpleError::from(e)))
}

fn is_key_existent(
    configuration: &str,
    project: &str,
    keyring: &str,
    key: &str,
) -> Result<bool, SimpleError> {
    let output = Command::new("gcloud")
        .arg("kms")
        .arg("keys")
        .arg("list")
        .arg("--location")
        .arg("global")
        .arg("--keyring")
        .arg(keyring)
        .arg("--filter")
        .arg(format!(
            "name:projects/{}/locations/global/keyRings/{}/cryptoKeys/{}",
            project, keyring, key
        ))
        .arg("--format")
        .arg("json")
        .arg("--configuration")
        .arg(configuration)
        .output()
        .or_else(|e| Err(SimpleError::from(e)))?;
    let output_stdout = str::from_utf8(&output.stdout).or_else(|e| Err(SimpleError::from(e)))?;
    let value: Vec<Configuration> =
        serde_json::from_str::<Vec<_>>(&output_stdout).or_else(|e| Err(SimpleError::from(e)))?;
    return Ok(value.len() > 0);
}

fn create_key(configuration: &str, keyring: &str, key: &str) -> Result<Output, SimpleError> {
    Command::new("gcloud")
        .arg("kms")
        .arg("keys")
        .arg("create")
        .arg(key)
        .arg("--location")
        .arg("global")
        .arg("--keyring")
        .arg(keyring)
        .arg("--purpose")
        .arg("encryption")
        .arg("--configuration")
        .arg(configuration)
        .output()
        .or_else(|e| Err(SimpleError::from(e)))
}
